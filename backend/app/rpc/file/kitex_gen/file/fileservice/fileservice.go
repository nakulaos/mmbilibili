// Code generated by Kitex v0.9.1. DO NOT EDIT.

package fileservice

import (
	file "backend/app/rpc/file/kitex_gen/file"
	"context"
	"errors"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "google.golang.org/protobuf/proto"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"NewMultiUpload": kitex.NewMethodInfo(
		newMultiUploadHandler,
		newNewMultiUploadArgs,
		newNewMultiUploadResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetMultiUploadUri": kitex.NewMethodInfo(
		getMultiUploadUriHandler,
		newGetMultiUploadUriArgs,
		newGetMultiUploadUriResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CompleteMultipart": kitex.NewMethodInfo(
		completeMultipartHandler,
		newCompleteMultipartArgs,
		newCompleteMultipartResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetSuccessChunks": kitex.NewMethodInfo(
		getSuccessChunksHandler,
		newGetSuccessChunksArgs,
		newGetSuccessChunksResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	fileServiceServiceInfo                = NewServiceInfo()
	fileServiceServiceInfoForClient       = NewServiceInfoForClient()
	fileServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return fileServiceServiceInfo
}

// for client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return fileServiceServiceInfoForStreamClient
}

// for stream client
func serviceInfoForClient() *kitex.ServiceInfo {
	return fileServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "FileService"
	handlerType := (*file.FileService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "file",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.9.1",
		Extra:           extra,
	}
	return svcInfo
}

func newMultiUploadHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.NewMultiUploadReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).NewMultiUpload(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *NewMultiUploadArgs:
		success, err := handler.(file.FileService).NewMultiUpload(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*NewMultiUploadResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newNewMultiUploadArgs() interface{} {
	return &NewMultiUploadArgs{}
}

func newNewMultiUploadResult() interface{} {
	return &NewMultiUploadResult{}
}

type NewMultiUploadArgs struct {
	Req *file.NewMultiUploadReq
}

func (p *NewMultiUploadArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(file.NewMultiUploadReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *NewMultiUploadArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *NewMultiUploadArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *NewMultiUploadArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *NewMultiUploadArgs) Unmarshal(in []byte) error {
	msg := new(file.NewMultiUploadReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var NewMultiUploadArgs_Req_DEFAULT *file.NewMultiUploadReq

func (p *NewMultiUploadArgs) GetReq() *file.NewMultiUploadReq {
	if !p.IsSetReq() {
		return NewMultiUploadArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NewMultiUploadArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NewMultiUploadArgs) GetFirstArgument() interface{} {
	return p.Req
}

type NewMultiUploadResult struct {
	Success *file.NewMultiUploadResp
}

var NewMultiUploadResult_Success_DEFAULT *file.NewMultiUploadResp

func (p *NewMultiUploadResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(file.NewMultiUploadResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *NewMultiUploadResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *NewMultiUploadResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *NewMultiUploadResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *NewMultiUploadResult) Unmarshal(in []byte) error {
	msg := new(file.NewMultiUploadResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *NewMultiUploadResult) GetSuccess() *file.NewMultiUploadResp {
	if !p.IsSetSuccess() {
		return NewMultiUploadResult_Success_DEFAULT
	}
	return p.Success
}

func (p *NewMultiUploadResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.NewMultiUploadResp)
}

func (p *NewMultiUploadResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NewMultiUploadResult) GetResult() interface{} {
	return p.Success
}

func getMultiUploadUriHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.GetMultiUploadUriReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).GetMultiUploadUri(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetMultiUploadUriArgs:
		success, err := handler.(file.FileService).GetMultiUploadUri(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetMultiUploadUriResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetMultiUploadUriArgs() interface{} {
	return &GetMultiUploadUriArgs{}
}

func newGetMultiUploadUriResult() interface{} {
	return &GetMultiUploadUriResult{}
}

type GetMultiUploadUriArgs struct {
	Req *file.GetMultiUploadUriReq
}

func (p *GetMultiUploadUriArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(file.GetMultiUploadUriReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetMultiUploadUriArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetMultiUploadUriArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetMultiUploadUriArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetMultiUploadUriArgs) Unmarshal(in []byte) error {
	msg := new(file.GetMultiUploadUriReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetMultiUploadUriArgs_Req_DEFAULT *file.GetMultiUploadUriReq

func (p *GetMultiUploadUriArgs) GetReq() *file.GetMultiUploadUriReq {
	if !p.IsSetReq() {
		return GetMultiUploadUriArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetMultiUploadUriArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetMultiUploadUriArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetMultiUploadUriResult struct {
	Success *file.GetMultiUploadUriResp
}

var GetMultiUploadUriResult_Success_DEFAULT *file.GetMultiUploadUriResp

func (p *GetMultiUploadUriResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(file.GetMultiUploadUriResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetMultiUploadUriResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetMultiUploadUriResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetMultiUploadUriResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetMultiUploadUriResult) Unmarshal(in []byte) error {
	msg := new(file.GetMultiUploadUriResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetMultiUploadUriResult) GetSuccess() *file.GetMultiUploadUriResp {
	if !p.IsSetSuccess() {
		return GetMultiUploadUriResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetMultiUploadUriResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.GetMultiUploadUriResp)
}

func (p *GetMultiUploadUriResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetMultiUploadUriResult) GetResult() interface{} {
	return p.Success
}

func completeMultipartHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.CompleteMultipartReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).CompleteMultipart(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CompleteMultipartArgs:
		success, err := handler.(file.FileService).CompleteMultipart(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CompleteMultipartResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCompleteMultipartArgs() interface{} {
	return &CompleteMultipartArgs{}
}

func newCompleteMultipartResult() interface{} {
	return &CompleteMultipartResult{}
}

type CompleteMultipartArgs struct {
	Req *file.CompleteMultipartReq
}

func (p *CompleteMultipartArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(file.CompleteMultipartReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CompleteMultipartArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CompleteMultipartArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CompleteMultipartArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CompleteMultipartArgs) Unmarshal(in []byte) error {
	msg := new(file.CompleteMultipartReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CompleteMultipartArgs_Req_DEFAULT *file.CompleteMultipartReq

func (p *CompleteMultipartArgs) GetReq() *file.CompleteMultipartReq {
	if !p.IsSetReq() {
		return CompleteMultipartArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CompleteMultipartArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CompleteMultipartArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CompleteMultipartResult struct {
	Success *file.CompleteMultipartResp
}

var CompleteMultipartResult_Success_DEFAULT *file.CompleteMultipartResp

func (p *CompleteMultipartResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(file.CompleteMultipartResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CompleteMultipartResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CompleteMultipartResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CompleteMultipartResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CompleteMultipartResult) Unmarshal(in []byte) error {
	msg := new(file.CompleteMultipartResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CompleteMultipartResult) GetSuccess() *file.CompleteMultipartResp {
	if !p.IsSetSuccess() {
		return CompleteMultipartResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CompleteMultipartResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.CompleteMultipartResp)
}

func (p *CompleteMultipartResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CompleteMultipartResult) GetResult() interface{} {
	return p.Success
}

func getSuccessChunksHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.GetSuccessChunksReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).GetSuccessChunks(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetSuccessChunksArgs:
		success, err := handler.(file.FileService).GetSuccessChunks(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetSuccessChunksResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetSuccessChunksArgs() interface{} {
	return &GetSuccessChunksArgs{}
}

func newGetSuccessChunksResult() interface{} {
	return &GetSuccessChunksResult{}
}

type GetSuccessChunksArgs struct {
	Req *file.GetSuccessChunksReq
}

func (p *GetSuccessChunksArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(file.GetSuccessChunksReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetSuccessChunksArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetSuccessChunksArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetSuccessChunksArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetSuccessChunksArgs) Unmarshal(in []byte) error {
	msg := new(file.GetSuccessChunksReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetSuccessChunksArgs_Req_DEFAULT *file.GetSuccessChunksReq

func (p *GetSuccessChunksArgs) GetReq() *file.GetSuccessChunksReq {
	if !p.IsSetReq() {
		return GetSuccessChunksArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetSuccessChunksArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetSuccessChunksArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetSuccessChunksResult struct {
	Success *file.GetSuccessChunksResp
}

var GetSuccessChunksResult_Success_DEFAULT *file.GetSuccessChunksResp

func (p *GetSuccessChunksResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(file.GetSuccessChunksResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetSuccessChunksResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetSuccessChunksResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetSuccessChunksResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetSuccessChunksResult) Unmarshal(in []byte) error {
	msg := new(file.GetSuccessChunksResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetSuccessChunksResult) GetSuccess() *file.GetSuccessChunksResp {
	if !p.IsSetSuccess() {
		return GetSuccessChunksResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetSuccessChunksResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.GetSuccessChunksResp)
}

func (p *GetSuccessChunksResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetSuccessChunksResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) NewMultiUpload(ctx context.Context, Req *file.NewMultiUploadReq) (r *file.NewMultiUploadResp, err error) {
	var _args NewMultiUploadArgs
	_args.Req = Req
	var _result NewMultiUploadResult
	if err = p.c.Call(ctx, "NewMultiUpload", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetMultiUploadUri(ctx context.Context, Req *file.GetMultiUploadUriReq) (r *file.GetMultiUploadUriResp, err error) {
	var _args GetMultiUploadUriArgs
	_args.Req = Req
	var _result GetMultiUploadUriResult
	if err = p.c.Call(ctx, "GetMultiUploadUri", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CompleteMultipart(ctx context.Context, Req *file.CompleteMultipartReq) (r *file.CompleteMultipartResp, err error) {
	var _args CompleteMultipartArgs
	_args.Req = Req
	var _result CompleteMultipartResult
	if err = p.c.Call(ctx, "CompleteMultipart", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetSuccessChunks(ctx context.Context, Req *file.GetSuccessChunksReq) (r *file.GetSuccessChunksResp, err error) {
	var _args GetSuccessChunksArgs
	_args.Req = Req
	var _result GetSuccessChunksResult
	if err = p.c.Call(ctx, "GetSuccessChunks", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
